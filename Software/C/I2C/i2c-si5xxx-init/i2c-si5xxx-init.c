// File: i2c-si5xxx-init.c
// Auth: M. Fras, Electronics Division, MPI for Physics, Munich
// Mod.: M. Fras, Electronics Division, MPI for Physics, Munich
// Date: 12 Feb 2018
// Rev.: 13 Feb 2018
//
// Initialize a Silicon Labs clock generator / jitter attenuator chip (e.g.
// Si5338, Si5324) via the I2C port of the FTDI FT232H chip.
//
// FTDI FT232H pinning:
// - ADBUS0(13): SCL
// - ADBUS1(14): SDA output
// - ADBUS2(15): SDA input
//
// CAUTION:
// The pins ADBUS1(14) and ADBUS2(15) *must* be tied together! Otherwise,
// either no data will be driven onto SDA or only a constant high signal level
// (i.e. NACK, 0xFF) will be received!
//



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mpsse.h>
#include "i2c-si5xxx-init.h"



// Function protoypes.
int show_help(char* prog_name);
void str_remove_char(char *str, char c);



int main(int argc, char **argv)
{
    int status;
    // Si5xxx data file.
    char *si5xxx_data_file_name;
    FILE *fp_si5xxx_data_file;
    char *si5xxx_data_file_line = NULL;     // This must be set to NULL so that getline reserves memory.
    size_t si5xxx_data_file_line_len = 0;   // This must be set to 0 so that getline reserves memory.
    char *si5xxx_data_file_line_ptr;
    ssize_t si5xxx_data_file_line_read;
    ssize_t si5xxx_data_file_line_number;
    char *si5xxx_data_file_line_search;
    // Si5xxx data strings.
    char *si5xxx_data_adr_str;
    char *si5xxx_data_byte_str;
    char *si5xxx_data_mask_str;
    // I2C options.
    int i2c_freq = ONE_HUNDRED_KHZ;
//    int i2c_freq = FOUR_HUNDRED_KHZ;
    // I2C address and data.
    int i2c_dev_adr;
    int i2c_data_adr;
    int i2c_data_byte;
    int i2c_data_mask;
    char i2c_data[4];

    // Check command line arguments.
    if(argc != 3) {
        show_help(argv[0]);
        return 1;
    }
    i2c_dev_adr = (int)(strtoul(argv[1], NULL, 0) & 0x7f);
    si5xxx_data_file_name = argv[2];

    // Initialize the I2C master device.
    status = i2c_init();
    if(status) {
        printf("%sUnable to open the I2C device.\n", PREFIX_ERROR);
        return 1;
    }
    // Set the I2C bus frequency.
    status = i2c_set_freq(i2c_freq);
    if(status) {
        printf("%sUnable to set the I2C frequency to %d Hz.\n", PREFIX_ERROR, i2c_freq);
        return 1;
    }
    // Set verbosity of the I2C library functions.
    i2c_set_verbose(1);

    // Show device information.
    #if DEBUG_LEVEL >= 1
    i2c_info();
    #endif



    // Open the Si5xxx data file (register map file or a C code header file
    // generated by the Silicon Labs ClockBuilder or the DSPLLsim software).
    fp_si5xxx_data_file = fopen(si5xxx_data_file_name, "rt");
    if(fp_si5xxx_data_file == NULL) {
        fprintf(stderr, "%sCannot open the Si5xxx data file `%s' for reading.\n", PREFIX_ERROR, si5xxx_data_file_name);
        return 1;
    }

    #if DEBUG_LEVEL >= 3
    printf("%sWriting data to the Si5xxx device:\n", PREFIX_DEBUG);
    #endif

    // Read data line by line from the data file.
    si5xxx_data_file_line_number = 0;
    while ((si5xxx_data_file_line_read = getline(&si5xxx_data_file_line, &si5xxx_data_file_line_len, fp_si5xxx_data_file)) != -1) {
        // Increase line number counter.
        si5xxx_data_file_line_number++;
        // Set working data file line pointer.
        si5xxx_data_file_line_ptr = si5xxx_data_file_line;
        // Remove all white spaces and tabs from the line.
        str_remove_char(si5xxx_data_file_line_ptr, ' ');
        str_remove_char(si5xxx_data_file_line_ptr, '\t');
        // Remove all line feed and carriage returns.
        str_remove_char(si5xxx_data_file_line_ptr, '\n');
        str_remove_char(si5xxx_data_file_line_ptr, '\r');
        // Remove all braces from the line.
        str_remove_char(si5xxx_data_file_line_ptr, '{');
        str_remove_char(si5xxx_data_file_line_ptr, '}');
        // Remove comments, stating at the comment mark "#".
        si5xxx_data_file_line_search = strstr(si5xxx_data_file_line_ptr, "#");
        if(si5xxx_data_file_line_search != NULL)
            *si5xxx_data_file_line_search = 0;
        // Remove comments, stating at the comment mark "//".
        si5xxx_data_file_line_search = strstr(si5xxx_data_file_line_ptr, "//");
        if(si5xxx_data_file_line_search != NULL)
            *si5xxx_data_file_line_search = 0;
        // Ignore the line, if it is too short.
        if(strlen(si5xxx_data_file_line_ptr) <= 1) continue;
        // Ignore the line, if it does not start with a number.
        switch(si5xxx_data_file_line_ptr[0]) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                break;
            default:
                continue;
        }

        // *** Get the I2C data address. ***
        // Search for comma, which separates the I2C data address from the data
        // byte.
        si5xxx_data_file_line_search = strstr(si5xxx_data_file_line_ptr, ",");
        // No comma found. => No data byte present, i.e. incomplete line.
        if(si5xxx_data_file_line_search == NULL) {
            fprintf(stderr, "%sIncomplete data file line %ld.\n", PREFIX_ERROR, si5xxx_data_file_line_number);
            fprintf(stderr, "%sAborting the I2C programming of the Si5xxx device.\n", PREFIX_ERROR);
            return 1;
        }
        // Replace the comma with a terminating 0.
        *si5xxx_data_file_line_search = 0;
        // Parse the I2C data address.
        si5xxx_data_adr_str = si5xxx_data_file_line_ptr;
        i2c_data_adr = (int)(strtoul(si5xxx_data_adr_str, NULL, 0) & 0xff);

        // *** Get the I2C data byte. ***
        // Parse the remaining data file line.
        si5xxx_data_byte_str = si5xxx_data_file_line_search + 1;
        // Search for comma, which separates the I2C data byte from the data
        // mask.
        si5xxx_data_file_line_search = strstr(si5xxx_data_byte_str, ",");
        // Comma found. => Data mask present.
        if(si5xxx_data_file_line_search != NULL) {
            // Replace the comma with a terminating 0.
            *si5xxx_data_file_line_search = 0;
        }
        // Check for the hex mark ('h') at the end of the data byte value in
        // the register map file.
        if(si5xxx_data_byte_str[strlen(si5xxx_data_byte_str)-1] == 'h') {
            // Replace the 'h' with a terminating 0.
            si5xxx_data_byte_str[strlen(si5xxx_data_byte_str)-1] = 0;
            // Parse hexadecimal value.
            i2c_data_byte = (int)(strtoul(si5xxx_data_byte_str, NULL, 16) & 0xff);
        } else {
            // Parse any value according to its format.
            i2c_data_byte = (int)(strtoul(si5xxx_data_byte_str, NULL, 0) & 0xff);
        }

        // *** Get the I2C data mask. ***
        // Parse the remaining data file line.
        si5xxx_data_mask_str = si5xxx_data_file_line_search;
        // No data mask available.
        if(si5xxx_data_mask_str == NULL) {
            i2c_data_mask = 0xff;
        // Data mask is specified.
        } else {
            // Move one character to the right from the terminating 0 of the
            // data byte string.
            si5xxx_data_mask_str++;
            // Check for the hex mark ('h') at the end of the data byte value
            // in the register map file.
            if(si5xxx_data_mask_str[strlen(si5xxx_data_mask_str)-1] == 'h') {
                // Replace the 'h' with a terminating 0.
                si5xxx_data_mask_str[strlen(si5xxx_data_mask_str)-1] = 0;
                // Parse hexadecimal value.
                i2c_data_mask = (int)(strtoul(si5xxx_data_mask_str, NULL, 16) & 0xff);
            } else {
                // Parse any value according to its format.
                i2c_data_mask = (int)(strtoul(si5xxx_data_mask_str, NULL, 0) & 0xff);
            }
        }

        #if DEBUG_LEVEL >= 3
        printf("%sdata address = %3d, data byte = 0x%02x, mask = 0x%02x\n", PREFIX_DEBUG, i2c_data_adr, i2c_data_byte, i2c_data_mask);
        #endif

        // *** Write the data to the Si5xxx device. ***
        // Set the I2C data address.
        i2c_data[0] = i2c_data_adr & 0xff;
        status = i2c_write(i2c_dev_adr, i2c_data, 1);
        if(status) {
            printf("%sUnable to set the I2C data address 0x%02x for device address 0x%02x.\n", PREFIX_ERROR, i2c_data_adr, i2c_dev_adr);
            return 1;
        }
        // Get the current value from the device at the register located at
        // address i2c_data_adr.
        status = i2c_read(i2c_dev_adr, i2c_data, 1);
        if(status) {
            printf("%sUnable to read 1 byte from the I2C chip address 0x%02x.\n", PREFIX_ERROR, i2c_dev_adr);
            return 1;
        }
        #if DEBUG_LEVEL >= 4
        printf("%s  original value read from the device    = 0x%02x\n", PREFIX_DEBUG, (i2c_data[0] & 0xff));
        #endif
        // For the correct use of the write-allowed data mask, please see the
        // Silicon Lab Si5338 reference manual (Si5338-RM.pdf), page 29.
        // ---
        // Clear the bits that are allowed to be accessed in the current value
        // of the register.
        i2c_data[0] &= ~i2c_data_mask;
        // Clear the bits in the desired data that are not allowed to be
        // accessed.
        i2c_data_byte &= i2c_data_mask;
        // Combine the cleared values to get the new value to write to the
        // desired register.
        i2c_data[1] = i2c_data[0] | i2c_data_byte;
        #if DEBUG_LEVEL >= 4
        printf("%s  masked data byte written to the device = 0x%02x\n", PREFIX_DEBUG, (i2c_data[1] & 0xff));
        #endif
        // Set the I2C data address.
        i2c_data[0] = i2c_data_adr & 0xff;
        // Write the I2C data.
        status = i2c_write(i2c_dev_adr, i2c_data, 2);
        if(status) {
            printf("%sUnable to write 2 byte to the I2C chip address 0x%02x, data address 0x%02x.\n", PREFIX_ERROR, i2c_dev_adr, i2c_data_adr);
            return 1;
        }
    }



    // Close the Si5338 data file and free the line buffer.
    fclose(fp_si5xxx_data_file);
    if(si5xxx_data_file_line)
        free(si5xxx_data_file_line);

    // Close the I2C device.
    i2c_close();

    return 0;
}



// Show help message.
int show_help(char* prog_name)
{
    printf("Initialize a Silicon Labs clock generator / jitter attenuator chip (e.g. Si5338,\n");
    printf("Si5324) via the I2C port of the FTDI FT232H chip.\n");
    printf("\n");
    printf("This software reads the settings from a register map file or a C code header\n");
    printf("file generated by the Silicon Labs ClockBuilder or the DSPLLsim software.\n");
    printf("\n");
    printf("Usage: %s CHIP-ADR REGISTER-MAP/C-HEADER-FILE\n", prog_name);
    return 0;
}



// Remove all occurances of a character in a string.
void str_remove_char(char *str, char c)
{
    char *a = str;
    char *b = str;
    do {
        *a = *b;
        if(*a != c) a++;
    } while(*b++ != 0);
}

